<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Arianna Terminal</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5/lib/codemirror.css" />
<style>
  body { margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; }
  .frame { border: 1px solid #666; margin: 8px; flex: 1; }
  #controls { display: flex; align-items: center; gap: 8px; margin: 8px; }
  #status { font-family: sans-serif; }
  #status::before {
    content: '';
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 4px;
    background: #666;
    vertical-align: middle;
  }
  #status.open::before { background: #0a0; }
  #status.close::before { background: #a00; }
  #status.error::before { background: #e69500; }
  #tab-bar { display: flex; gap: 4px; margin: 0 8px; }
  .tab { position: relative; padding: 4px 16px 4px 8px; cursor: pointer; }
  .tab.active { background: #ddd; }
  .close-tab { position: absolute; right: 4px; top: 2px; cursor: pointer; }
  #terminal-container { flex: 1; display: flex; }
  .hidden { display: none; }
</style>
</head>
<body>
<div id="controls">
  <span id="status" class="close">close</span>
  <button id="new-tab">new</button>
</div>
<div id="tab-bar"></div>
<dialog id="token-dialog">
  <label for="token-input">Token:</label>
  <input id="token-input" type="text" />
  <button id="token-save">Save</button>
</dialog>
<div id="terminal-container"></div>
<canvas id="three-canvas" class="frame"></canvas>
<script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.164.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5/lib/codemirror.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5/mode/python/python.js"></script>
<script>
(async function() {
if (window.Telegram && window.Telegram.WebApp) {
  window.Telegram.WebApp.ready();
}
const params = new URLSearchParams(location.search);
const editPath = params.get('edit');
const statusEl = document.getElementById('status');
const tokenDialog = document.getElementById('token-dialog');
const tokenInput = document.getElementById('token-input');
const tabBar = document.getElementById('tab-bar');
const container = document.getElementById('terminal-container');
const sessions = {};
let activeSid = null;
let tabCount = 0;

function authHeaders() {
  const token = localStorage.getItem('amlkToken');
  return token ? { Authorization: 'Basic ' + btoa('x:' + token) } : {};
}

const threeCanvas = document.getElementById('three-canvas');
const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas });
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  threeCanvas.clientWidth / threeCanvas.clientHeight,
  0.1,
  1000
);
camera.position.set(0, 0, 5);
const controls = new THREE.OrbitControls(camera, renderer.domElement);
function resizeRenderer() {
  renderer.setSize(threeCanvas.clientWidth, threeCanvas.clientHeight);
  camera.aspect = threeCanvas.clientWidth / threeCanvas.clientHeight;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', resizeRenderer);
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
resizeRenderer();
animate();

if (editPath) {
  document.getElementById('controls').classList.add('hidden');
  tabBar.classList.add('hidden');
  container.classList.add('hidden');
  threeCanvas.classList.add('hidden');
  const editorWrap = document.createElement('div');
  editorWrap.className = 'frame';
  const textarea = document.createElement('textarea');
  editorWrap.appendChild(textarea);
  document.body.appendChild(editorWrap);
  const saveBtn = document.createElement('button');
  saveBtn.textContent = 'save';
  saveBtn.style.margin = '8px';
  document.body.appendChild(saveBtn);
  const editor = CodeMirror.fromTextArea(textarea, { lineNumbers: true });
  const headers = authHeaders();
  const res = await fetch(`/upload?path=${encodeURIComponent(editPath)}`, { headers });
  editor.setValue(await res.text());
  saveBtn.addEventListener('click', async () => {
    const content = editor.getValue();
    const blob = new Blob([content], { type: 'text/plain' });
    let data = blob;
    if (window.Telegram && window.Telegram.WebApp) {
      const saved = await window.Telegram.WebApp.saveFile({
        data: await blob.arrayBuffer(),
        file_name: editPath.split('/').pop(),
        mime_type: 'text/plain',
      });
      data = await window.Telegram.WebApp.openFile({ path: saved.path });
    }
    const form = new FormData();
    form.append('file', new File([data], editPath.split('/').pop(), { type: 'text/plain' }));
    await fetch(`/save?path=${encodeURIComponent(editPath)}`, {
      method: 'POST',
      headers,
      body: form,
    });
  });
  return;
}

function handlePlot(dataStr) {
  let payload;
  try {
    payload = JSON.parse(dataStr);
  } catch (e) {
    console.error('Invalid plot data', e);
    return;
  }
  if (!payload.points) return;
  const geometry = new THREE.BufferGeometry();
  const vertices = new Float32Array(payload.points.flat());
  geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
  const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
  const line = new THREE.Line(geometry, material);
  scene.add(line);
}

function handleModel(modelStr) {
  while (scene.children.length) {
    scene.remove(scene.children[0]);
  }
  let mesh;
  const name = modelStr.trim().toLowerCase();
  if (name === 'cube') {
    mesh = new THREE.Mesh(new THREE.BoxGeometry(), new THREE.MeshNormalMaterial());
  } else if (name === 'sphere') {
    mesh = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), new THREE.MeshNormalMaterial());
  }
  if (mesh) scene.add(mesh);
}
function handleEdit(path) {
  const url = `${location.pathname}?edit=${encodeURIComponent(path)}`;
  if (window.Telegram && window.Telegram.WebApp) {
    window.Telegram.WebApp.openLink(url, { try_browser: true });
  } else {
    window.open(url, '_blank');
  }
}
function setStatus(state) {
  statusEl.textContent = state;
  statusEl.className = state;
}
function connect(sid, term) {
  const token = localStorage.getItem('amlkToken');
  if (!token) {
    tokenDialog.showModal();
    return null;
  }
  const ws = new WebSocket(`ws://${location.host}/ws?token=${token}&sid=${sid}`);
  ws.onopen = () => {
    setStatus('open');
    term.write('>> ');
  };
  ws.onmessage = ev => {
    const lines = ev.data.split('\n');
    let out = '';
    for (const line of lines) {
      if (line.startsWith('__PLOT__')) {
        handlePlot(line.slice(8));
      } else if (line.startsWith('__MODEL__')) {
        handleModel(line.slice(9));
      } else if (line.startsWith('__EDIT__')) {
        handleEdit(line.slice(8));
      } else if (line) {
        out += '\r\n' + line;
      }
    }
    term.write(out + '\r\n>> ');
  };
  ws.onclose = () => {
    setStatus('close');
    term.write('\r\n[connection closed]\r\n');
  };
  ws.onerror = () => {
    setStatus('error');
  };
  return ws;
}
function setActive(sid) {
  if (activeSid && sessions[activeSid]) {
    sessions[activeSid].tab.classList.remove('active');
    sessions[activeSid].el.classList.add('hidden');
  }
  activeSid = sid;
  localStorage.setItem('amlkActiveSid', sid);
  const session = sessions[sid];
  session.tab.classList.add('active');
  session.el.classList.remove('hidden');
}
function removeSession(sid) {
  const session = sessions[sid];
  if (!session) return;
  session.ws && session.ws.close();
  session.tab.remove();
  session.el.remove();
  delete sessions[sid];
  if (activeSid === sid) {
    const next = Object.keys(sessions)[0];
    if (next) {
      setActive(next);
    } else {
      activeSid = null;
      localStorage.removeItem('amlkActiveSid');
    }
  }
}
function createSession(sid) {
  sid = sid || (window.crypto ? crypto.randomUUID() : String(Date.now()));
  const el = document.createElement('div');
  el.className = 'frame hidden';
  container.appendChild(el);
  const term = new Terminal({
    cursorBlink: true,
    theme: window.matchMedia('(prefers-color-scheme: dark)').matches ? {
      background: '#1e1e1e',
      foreground: '#d4d4d4'
    } : {
      background: '#ffffff',
      foreground: '#000000'
    }
  });
  term.open(el);
  const ws = connect(sid, term);
  sessions[sid] = { term, ws, el, buffer: '' };
  const tab = document.createElement('div');
  tab.className = 'tab';
  tab.textContent = `#${++tabCount}`;
  const closeBtn = document.createElement('span');
  closeBtn.textContent = 'Ã—';
  closeBtn.className = 'close-tab';
  closeBtn.addEventListener('click', ev => {
    ev.stopPropagation();
    removeSession(sid);
  });
  tab.appendChild(closeBtn);
  tab.addEventListener('click', () => setActive(sid));
  tabBar.appendChild(tab);
  sessions[sid].tab = tab;
  term.onData(data => {
    const session = sessions[sid];
    if (!session) return;
    if (data === '\r') {
      if (session.ws && session.ws.readyState === WebSocket.OPEN) {
        session.ws.send(session.buffer);
      }
      session.buffer = '';
    } else if (data === '\u007f') {
      if (session.buffer.length > 0) {
        session.buffer = session.buffer.slice(0, -1);
        term.write('\b \b');
      }
    } else {
      session.buffer += data;
      term.write(data);
    }
  });
  return sid;
}
document.getElementById('new-tab').addEventListener('click', () => {
  setActive(createSession());
});
document.getElementById('token-save').addEventListener('click', () => {
  localStorage.setItem('amlkToken', tokenInput.value);
  tokenDialog.close();
  if (!activeSid) {
    setActive(createSession());
  }
});
if (localStorage.getItem('amlkToken')) {
  const last = localStorage.getItem('amlkActiveSid');
  setActive(createSession(last));
} else {
  tokenDialog.showModal();
}

document.addEventListener('dragover', ev => ev.preventDefault());
document.addEventListener('drop', async ev => {
  ev.preventDefault();
  const file = ev.dataTransfer.files[0];
  if (!file || !(window.Telegram && window.Telegram.WebApp)) return;
  try {
    const buffer = await file.arrayBuffer();
    const saved = await window.Telegram.WebApp.saveFile({
      data: buffer,
      file_name: file.name,
      mime_type: file.type,
    });
    const opened = await window.Telegram.WebApp.openFile({ path: saved.path });
    const form = new FormData();
    form.append('file', new File([opened], file.name, { type: file.type }));
    await fetch('/upload', { method: 'POST', headers: authHeaders(), body: form });
  } catch (err) {
    console.error('upload failed', err);
  }
});
})();
</script>
</body>
</html>
